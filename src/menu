menu() {
  local CYAN=$'\e[96m'
  local GREEN=$'\e[92m'
  local YELLOW=$'\e[93m'
  local RED=$'\e[91m'
  local RESET=$'\e[0m'

  # quick combos view (early exit if requested)
  if [ "$1" = "combos" ]; then
    echo -e "${YELLOW}ðŸ”¹ BFH â€” menu combos${RESET}"
    echo -e ""
    echo -e "${CYAN}DOM-XSS check:${RESET}"
    echo -e "  ${GREEN}pcut 4d tparams 2 | qsreplace \"axss1'saxss2\\\"saxss3<s\" | tee 4r"
    echo -e "  reptile 4r -E \"axss3<s|axss2\\\"s|axss1's\" --ua-chrome -A 800 -B 800"
    echo -e "  reptile finds${RESET}"
    echo -e ""
    echo -e "${CYAN}CORS misconfig check:${RESET}"
    echo -e "  ${GREEN}epaths 1 normurls > ep1 && cors ep1${RESET}"
    echo -e ""
    echo -e "${CYAN}PARAMS DISCOVER mini chaos:${RESET}"
    echo -e "  ${GREEN}epaths 1 normurls | cut -d/ -f3-> ep1 && echo 'Try gbr ->ep1' ${RESET}"
    echo -e ""
    echo -e "${CYAN}POTENTIAL FOR XSS X_X:${RESET}"
    echo -e "  ${GREEN}cat 4d | qsreplace 'ampchecks&ampchecks' >ampchecks && hf ampchecks 'ampchecks&ampchecks' --ua-chrome && hf finds ${RESET}"
    echo -e ""
    echo -e "${YELLOW}Tip:${RESET} Copy and paste each to execute combos."
    return
  fi



  source "$BFH_PATH/DESCRIPTIONS.sh"

  echo -e "${CYAN}ðŸ”¥ Available Functions in BFH ðŸ”¥${RESET}"

  for f in "$BFH_PATH"/src/*; do
    name=$(basename "$f" | tr '[:upper:]' '[:lower:]')
    desc_func="${name}_desc"

    printf "  ${GREEN}%s()${RESET}" "$name"

    if declare -f "$desc_func" >/dev/null 2>&1; then
      # capture description once and trim trailing newlines
      desc_text="$($desc_func 2>/dev/null || true)"
      desc_text="$(printf '%s' "$desc_text" | sed -e $'s/\r$//' -e ':a;N;$!ba;s/\n*$//')"

      if [ -z "$desc_text" ]; then
        echo ""
        continue
      fi

      # Replace ALL occurrences of "COOL!" with colored version using bash expansion
      desc_colored="${desc_text//COOL!/${YELLOW}COOL!${RESET}}"

      # print first line (may contain colored COOL!), interpret escapes with %b
      IFS=$'\n' read -r first_line rest <<<"$desc_colored"
      printf " - %b\n" "$first_line"

      # print remaining lines indented; use %b so escapes are interpreted
      if [ -n "$rest" ]; then
        printf '%s\n' "$rest" | while IFS= read -r line; do
          printf "     %b\n" "$line"
        done
      fi
    else
      echo ""
    fi
  done

  echo -e "\n${YELLOW}ðŸ”„ Checking for updates...${RESET}"
  cd "$BFH_PATH" || return

  git remote update > /dev/null 2>&1
  LOCAL=$(git rev-parse HEAD 2>/dev/null || echo "")
  REMOTE=$(git rev-parse origin/main 2>/dev/null || echo "")

  if [[ -z "$LOCAL" || -z "$REMOTE" || "$LOCAL" != "$REMOTE" ]]; then
    echo -e "${RED}ðŸš¨ You are NOT using the latest version!${RESET}"
    echo -e "ðŸ‘‰ Run ${CYAN}updatebfh${RESET} to update."
  else
    echo -e "${GREEN}âœ… You are using the latest version.${RESET}"
  fi

  cd - > /dev/null
}
